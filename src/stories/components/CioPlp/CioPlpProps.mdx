import { ArgTypes } from '@storybook/blocks';
import Groups from '../../../components/Groups';
import Pagination from '../../../components/Pagination';

## Formatters

Formatters will be used to modify how certain fields are rendered.

| Property    | Type                        | Description           |
| ----------- | --------------------------- | --------------------- |
| formatPrice | `(price: number) => string` | Format price function |

## Callbacks

Callbacks will be composed with the library's internal tracking calls for a given event.

| Property           | Type                                                                            | Description                            |
| ------------------ | ------------------------------------------------------------------------------- | -------------------------------------- |
| onAddToCart        | `(event: React.MouseEvent, item: Item, selectedVariation?: Variation) => void` | Product add to cart callback function  |
| onProductCardClick | `(event: React.MouseEvent, item: Item) => void`                                 | Product click callback function        |
| onSwatchClick      | `(e: React.MouseEvent, clickedSwatch: SwatchItem) => void`                      | Product swatch click callback function |
| onRedirect         | `(url: string) => void`                                                         | Redirect callback function             |

## ItemFieldGetters

ItemFieldGetters maps the fields sent in the catalog feeds to the fields the library expects for rendering.

| Property | Type                     | Description        |
| -------- | ------------------------ | ------------------ |
| getPrice | `(item: Item) => number` | Get price function |

## Configuration Options

Configuration options for customizing component behavior within CioPlp.

### `groupsConfigs`

Configuration options for the Groups component behavior.

<ArgTypes of={Groups} />

### `paginationConfigs`

Configuration options for pagination functionality.

| Property       | Type     | Description                                          |
| -------------- | -------- | ---------------------------------------------------- |
| windowSize     | `number` | Number of page buttons to show in pagination        |
| resultsPerPage | `number` | Override the results per page set at Provider level |

### `sortConfigs`

Configuration options for sorting functionality. No specific configurations available yet.

### `filterConfigs`

Configuration options for filters functionality. No specific configurations available yet.

## UrlHelpers

URL Helpers are used for managing the URL and request state. These functions define how this library modifies and parses the URL.

| Property              | Type                                                                     | Description                                                     |
| --------------------- | ------------------------------------------------------------------------ | --------------------------------------------------------------- |
| getUrl                | `() => string \| undefined`                                              | Get the current URL for a page (Default: getting current href) |
| setUrl                | `(newEncodedUrlState: string) => void`                                   | Set the window href using the provided URL                     |
| getStateFromUrl       | `(urlString: string) => RequestConfigs`                                  | Parses the given URL string to a request configuration state   |
| getUrlFromState       | `(state: RequestConfigs, options: QueryParamEncodingOptions) => string` | Convert the request configuration state to a URL string        |
| defaultQueryStringMap | `DefaultQueryStringMap`                                                  | Provides a mapping for the query parameters that is used in URL |

### getUrl

Default Implementation:

**Type:** `() => string | undefined`

```javascript
function getUrl() {
  if (typeof window === 'undefined') return undefined;
  return window.location.href;
}
```

### setUrl

Default Implementation:

**Type:** `(newEncodedUrlState: string) => void`

```javascript
function setUrl(newUrlWithEncodedState) {
  if (typeof window === 'undefined') return;
  window.location.href = newUrlWithEncodedState;
}
```

### getStateFromUrl

Default Implementation:

**Type:** `(urlString: string) => RequestConfig`

```javascript
function getStateFromUrl(url) {
  const urlObject = new URL(url);
  const urlParams = urlObject.searchParams;
  const paths = decodeURI(urlObject?.pathname)?.split('/');
  const query = urlParams.get(defaultQueryStringMap.query);
  let filterName;
  let filterValue;

  if (!query && paths.length > 0) {
    filterName = 'group_id';
    filterValue = paths[paths.length - 1];
  }

  const rawState = {};
  Object.entries(defaultQueryStringMap).forEach(([key, val]) => {
    const storedVal = urlParams.get(val);
    if (storedVal != null) {
      rawState[key] = storedVal;
    }
  });

  const filters = extractFiltersFromUrl(urlParams);

  const {
    page,
    offset,
    resultsPerPage,
    fmtOptions,
    hiddenFacets,
    hiddenFields,
    variationsMap,
    preFilterExpression,
    ...rest
  } = rawState;

  const state = { ...rest };
  if (page) state.page = Number(page);
  if (offset) state.offset = Number(offset);
  if (resultsPerPage) state.resultsPerPage = Number(resultsPerPage);
  if (filters) state.filters = filters;
  if (filterName) {
    state.filterName = filterName;
    state.filterValue = filterValue;
  }

  return state;
}
```

### getUrlFromState

Default Implementation:

**Type:** `(state: RequestConfigs, options: QueryParamEncodingOptions) => string`

```javascript
function getUrlFromState(state, url) {
  const urlObject = new URL(url);
  let { pathname } = urlObject;

  if (state.filterName && state.filterValue) {
    if (pathname.match(/(group_id|collection_id)\/[^/]+$/)) {
      pathname = pathname.replace(
        /\/(group_id|collection_id)\/[^/]+$/,
        `/${state.filterName}/${state.filterValue}`,
      );
    } else {
      pathname = `/${state.filterName}/${state.filterValue}`;
    }
  }

  const params = new URLSearchParams();

  Object.entries(state).forEach(([key, val]) => {
    if (defaultQueryStringMap[key] === undefined) {
      return;
    }

    let encodedVal = '';

    if (key === 'filters' && state.filters) {
      getFilterParamsFromState(params, state.filters);
    } else if (typeof val !== 'string') {
      encodedVal = JSON.stringify(val);
    } else {
      encodedVal = val;
    }

    if (encodedVal) {
      params.set(defaultQueryStringMap[key], encodedVal);
    }
  });

  return `${urlObject.origin}${pathname}?${params.toString()}`;
}
```

### defaultQueryStringMap

Default Implementation:

**Type:** `DefaultQueryStringMap`

```javascript
const defaultQueryStringMap = Object.freeze({
  query: 'q',
  page: 'page',
  offset: 'offset',
  resultsPerPage: 'numResults',
  filters: 'filters',
  sortBy: 'sortBy',
  sortOrder: 'sortOrder',
  section: 'section',
});
